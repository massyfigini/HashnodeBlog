---
title: "My Notes for earning the Oracle Database SQL Certified Associate (for SQL Server Developers)"
datePublished: Sun Sep 07 2025 06:28:24 GMT+0000 (Coordinated Universal Time)
cuid: cmf9bagl9000302k1a8083m3v
slug: my-notes-for-earning-the-oracle-database-sql-certified-associate-for-sql-server-developers
tags: sql, certification, oracle-database

---

*Disclaimer: This post is based on my personal notes and reflections. I used AI (ChatGPT by OpenAI) only to improve grammar, structure, and readability.*

## Introduction

The Oracle exam 1Z0-071 is what you need to earn the Oracle Database SQL Certified Associate certification. I passed it yesterday morning with a score of 90% (63% is the minimum).

I am a SQL developer with 15 years of T-SQL experience, but only limited exposure to Oracle SQL, and I haven’t worked on an Oracle database since 2019.

My first step was to review all the topics and subtopics listed on the [official exam page](https://education.oracle.com/oracle-database-sql/pexam_1Z0-071), then refresh my knowledge and practice in my local environment. I also used ChatGPT to clean up my notes, but I always checked the official Oracle documentation, since ChatGPT provided incorrect results on this topic on many occasions.

For me, the Oracle exam felt more challenging because only a handful of questions (fewer than five) required a single answer. The majority asked for 2–4 correct answers out of 5–7 options, and if you missed even one (e.g., 3 out of 4 correct), the entire question was marked wrong. In Microsoft exams, that same result would count as 75% correct. This means that in Oracle, your percentage can quickly drop toward the 63% passing threshold, while in Microsoft, partial credit can actually push you up toward the 70% passing mark.

Note: These notes will help you pass the exam only if you are an experienced SQL Server developer. Advanced concepts that apply equally to both SQL Server and Oracle are not covered here, yet they make up a large portion of the exam questions. After taking the exam, I can say that about 95% of the questions can be answered using these notes and advanced SQL Server experience. Only a few questions (1–3) covered topics not included in this post, such as date format variations.

## Topic 1 - Relational Database concepts:

Subtopics:

* Explaining the theoretical and physical aspects of a relational database
    
* Relating clauses in SQL Select Statement to Components of an ERD
    
* Explaining the relationship between a database and SQL
    

### Explaining the theoretical and physical aspects of a relational database

#### **Theoretical Aspects**

These are based on Relational Database Theory by E. F. Codd, this is mandatory for each database developer and I’m not covering it in depth. It is everything related to the relational model, cardinality in relationships (1:N, etc.), type and meaning of keys, constraints, ACID properties (Atomicity, Consistency, Isolation, Durability), normalization and common normal forms (1NF, 2NF, 3NF meanings).

#### **Physical Aspects**

These relate to how data is stored, accessed, and managed on disk for Oracle database. Oracle organizes storage into logical structures and maps them onto physical files on disk.

Tablespace → contains Datafiles

Datafile → contains Segments

Segment → made of Extents

Extent → made of Oracle Blocks

Block → smallest I/O unit

* Tablespaces: logical storage units within a database.
    
* Datafiles: physical files on disk that store the data for tablespaces. Each tablespace consists of one or more datafiles.
    
* Blocks: the smallest unit of I/O in Oracle DB.
    
* Extents: collection of blocks.
    
* Segments: collection of extents (e.g., a table or index segment).
    

Default size of a block is 8 KB (but it can be 2 KB to 32 KB depending on configuration).

When you create a table:

* Oracle allocates a segment for it (specifically a table segment).
    
* Each row inserted goes into a block.
    
* When existing blocks are full, Oracle allocates a new extent (a group of contiguous blocks).
    
* Extents grow in size dynamically if AUTOEXTEND is enabled on the tablespace.
    
* If a row grows (e.g., due to an UPDATE) and no space is left in the block, the row may be migrated or chained into another block.
    

If you create an index, Oracle creates a separate index segment.

### Relating clauses in SQL Select Statement to Components of an ERD

This is essentially related to all SQL clauses (SELECT, FROM, WHERE, etc.), I will not go in depth.

### Explaining the relationship between a database and SQL

SQL is just the standard language to interact with a relational database, probably this topic includes also knowing purpose of each SQL sublanguages

| **Sublanguage** | **Purpose** | **Common commands** |
| --- | --- | --- |
| **DDL** (Data Definition Language) | Defines and modifies schema/structures | `CREATE`, `ALTER`, `DROP`, `TRUNCATE` |
| **DML** (Data Manipulation Language) | Manipulates data in existing objects | `INSERT`, `UPDATE`, `DELETE`, `MERGE` |
| **DQL** (Data Query Language) - *Oracle official documentation put does not include DQL and put select under DML!* | Retrieve data from the database | `SELECT` |
| **DCL** (Data Control Language) | Manage permissions and access control | `GRANT`, `REVOKE` |
| **TCL** (Transaction Control Language) | Manages transactions and ensures ACID compliance | `COMMIT`, `ROLLBACK`, `SAVEPOINT`, `SET TRANSACTION` |

## Topic 2 - Retrieving Data using the SQL SELECT Statement

Subtopics:

* Using Table and Column aliases
    
* Using The SQL SELECT statement
    
* Using concatenation operator, literal character strings, alternative quote operator, and the DISTINCT keyword
    
* Using Arithmetic expressions and NULL values in the SELECT statement
    

### Using Table and Column Aliases

`SELECT column_name AS alias_name FROM table_name AS alias_table;`

* AS is optional in Oracle
    
* Aliases with spaces or special characters must be enclosed in double quotes
    

Using table aliases can:

* Help Oracle parse complex queries more efficiently (especially with long object names or subqueries)
    
* Reduce ambiguity in multi-table joins
    
* Improve query readability and optimizer plan generation in large queries, so resulting even in performance improvements in some (rare) cases
    

### Using the SQL SELECT Statement

Nothing really different from standard SQL.

### Using Concatenation, Literals, Quote Operator, DISTINCT

* Concatenation Operator (||)
    
    `SELECT first_name || ' ' || last_name AS full_name FROM employees;`
    
* Literal Character Strings. I think they means something like this:
    
    `SELECT 'Welcome to Oracle SQL!' AS greeting FROM dual;`
    
* Quote Operator. It means the q notation to avoid escaping ‘:
    
    `SELECT q'[It's a great day!]' AS message FROM dual;`
    
    You can use different delimiters like q'{...}', q'(...)', q'&lt;...&gt;', q'&lt;...&gt;'
    
* DISTINCT keyword to eliminate duplicate
    
    `SELECT DISTINCT department_id FROM employees;`
    

### Using Arithmetic Expressions and NULL Values

* You can use standard math in the SELECT clause: +, -, \*, /
    
* Any arithmetic operation involving NULL results in NULL
    
* Use NVL() to handle NULLs:
    
    `SELECT salary + NVL(commission_pct, 0) AS total_pay FROM employees;`
    

## Topic 3 - Restricting and Sorting Data

Subtopics:

* Applying Rules of precedence for operators in an expression
    
* Limiting Rows Returned in a SQL Statement
    
* Using Substitution Variables
    
* Using the DEFINE and VERIFY commands
    
* Sorting Data
    

### Applying Rules of precedence for operators in an expression

Operator Precedence in Oracle SQL (High to Low):

| **Operator** | **Description** |
| --- | --- |
| `+`, `-` (Unary) | Positive, Negative |
| `*`, `/` | Multiplication, Division |
| `+`, `-` (Binary) | Addition, Subtraction |
| \` |  |
| `=`, `<`, `>`, etc. | Comparison ops |
| `IS [NOT] NULL`, `LIKE`, `BETWEEN`, `IN` | Logical predicates |
| `NOT` | Logical NOT |
| `AND` | Logical AND |
| `OR` | Logical OR |

### Limiting Rows Returned in a SQL Statement

* FETCH FIRST N ROWS (take first n rows)
    
    `SELECT * FROM employees ORDER BY salary DESC FETCH FIRST 5 ROWS ONLY;`
    
* OFFSET/FETCH (take first n rows after some rows)
    
    `SELECT * FROM employees ORDER BY employee_id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;`
    
* ROWNUM (assigned before sorting so just for quick sampling e.g. for preview)
    
    `SELECT * FROM employees WHERE ROWNUM <= 5;`
    

### Using Substitution Variables

Used in SQL\*Plus or tools like SQL Developer for interactive input.

* &variable – Prompts once:
    
    `SELECT * FROM employees WHERE department_id = &dept_id;`
    
    Oracle will prompt: *Enter value for dept\_id:* and replace it during execution.
    
    `SELECT * FROM employees WHERE department_id = &dept_id;`
    
    Oracle still prompts you, but the value is placed inside single quotes, so it becomes a string literal
    
* &&variable – Stores value for reuse:
    
    `SELECT FROM employees WHERE department_id = &&dept_id; SELECT FROM departments WHERE department_id = &&dept_id;`
    
    Oracle will prompt once and reuse the value.
    

### Using the DEFINE and VERIFY commands

* DEFINE – Assigns a permanent variable
    
    `DEFINE dept = 10 SELECT * FROM employees WHERE department_id = &dept;`
    
    To check the variable: `DEFINE`
    
    To undefine it: `UNDEFINE dept`
    
    You can use it also if you need to search for a value that starts with & or &&
    
    ```sql
    SET DEFINE OFF;
    
    -- Now this query will not prompt for job_id but search for &1 string
    SELECT * FROM employees WHERE job_id = '&1';
    ```
    
* VERIFY – Shows how substitution variables were resolved
    
    `SET VERIFY ON`
    
    Oracle displays both the original and substituted SQL statements (useful for debugging interactive scripts). It is not supported in graphical tools like SQL Developer, but specific to SQL\*Plus and environments that emulate it.
    

### Sorting Data

You sort data in a query using the ORDER BY clause:

* Basic sorting: `ORDER BY field`
    
* Descending order: `ORDER BY field DESC`
    
* Multiple columns: `ORDER BY department_id ASC, salary DESC`
    
* You can sort by column alias: `SELECT field AS a FROM table ORDER BY a`
    
* You can sort by position: `ORDER BY 1`
    
* With default settings, character sorting is case-sensitive
    

## Topic 4 - Using Single-Row Functions to Customize Output

Subtopics:

* Manipulating strings with character functions in SQL SELECT and WHERE clauses
    
* Performing arithmetic with date data
    
* Manipulating numbers with the ROUND, TRUNC and MOD functions
    
* Manipulating dates with the date function
    

### Manipulating strings with character functions in SQL SELECT and WHERE clauses

Common Character Functions:

| **Function** | **Description** | **Example** |
| --- | --- | --- |
| `UPPER()` | Converts to uppercase | `UPPER('oracle')` → `'ORACLE'` |
| `LOWER()` | Converts to lowercase | `LOWER('ORACLE')` → `'oracle'` |
| `INITCAP()` | Capitalizes first letter of each word | `INITCAP('oracle sql')` → `'Oracle Sql'` |
| `LENGTH()` | Returns number of characters | `LENGTH('hello')` → `5` |
| `SUBSTR()` | Extracts part of a string | `SUBSTR('hello', 2, 3)` → `'ell'` |
| `INSTR()` | Finds position of a substring | `INSTR('hello world', 'o')` → `5` |
| `CONCAT()` | Concatenates two strings (you can use |  |
| `TRIM()` | Removes specified characters (It trims any combination of those characters from the edges) | `TRIM(' H ' FROM ' HHH ')` → `'H'` |
| `LTRIM()` | Removes leading chars → Removes any characters from the beginning (left) of the string that appear in the trim set, until it hits a character that is not in the set. | `LTRIM('abcabc123', 'abc')` → `'123'` |
| `RTRIM()` | Removes trailing chars | `RTRIM('123abcabc', 'abc')` → `'123'` |
| `REPLACE()` | Replace part of a string | `REPLACE('abcabc', 'a', 'x')` → `'xbcxbc'` |

### Performing arithmetic with date data

In Oracle, dates can be added or subtracted, and you can also calculate intervals between dates.

| **Operation** | **Description** | **Example** |
| --- | --- | --- |
| date + n | Adds n days | `SYSDATE + 7` = 7 days later |
| date - n | Subtracts n days | `SYSDATE - 30` = 30 days ago |
| date1 - date2 | Returns number of days between | `'2024-04-01' - '2024-03-28'` = `4` |

You can also use TO\_YMINTERVAL in your logic, an Oracle SQL conversion function used to create an INTERVAL YEAR TO MONTH value from a string. `TO_YMINTERVAL('[-]years-months')`

```sql
SELECT TO_YMINTERVAL('1-6') FROM dual;
-- Returns: +000000001-06

SELECT TO_YMINTERVAL('-2-3') FROM dual;
-- Returns: -000000002-03

SELECT SYSDATE + TO_YMINTERVAL('2-0') AS two_years_later FROM dual;
-- Adds 2 years to current date
```

### Manipulating numbers with the ROUND, TRUNC and MOD functions

| **Function** | **Description** | **Example** |
| --- | --- | --- |
| `ROUND(n, d)` | Rounds n to d decimal places. If n is negative it rounds to the nearest 10, 100, etc. | `ROUND(123.456, 2)` → 123.46 |
| `TRUNC(n, d)` | Truncates n to d decimal places. If n is negative it truncate to the nearest 10, 100, etc. | `TRUNC(123.456, 2)` → 123.45 |
| `MOD(m, n)` | Returns the remainder of m / n | `MOD(10, 3)` → 1 |
| `FLOOR(n)` | Returns the largest integer ≤ n | `FLOOR(4.8)` → 4 `FLOOR(-4.8)` → -5 |
| `CEIL(n)` | Returns the smallest integer that is greater than or equal to a given number | `CEIL(4.3)` → 5 `CEIL(-2.8)` → -2 |

ROUND(), TRUNC(), FLOOR(), CEIL() can be also used with dates.

### Manipulating dates with the date function

Common Date Functions:

| **Function** | **Description** | **Example** |
| --- | --- | --- |
| `SYSDATE` | Returns current date & time | `SYSDATE` |
| `CURRENT_DATE` | Current date in session time zone | `CURRENT_DATE` |
| `SYSTIMESTAMP` | Current timestamp (date + time) | `SYSTIMESTAMP` |
| `MONTHS_BETWEEN` | Months between two dates (decimal, recent date first) | `MONTHS_BETWEEN('2025-04-01', '2025-01-01')` → `3` |
| `ADD_MONTHS` | Adds/subtracts months to a date | `ADD_MONTHS(SYSDATE, 6)` |
| `NEXT_DAY` | Returns next specific weekday after a date | `NEXT_DAY(SYSDATE, 'MONDAY')` |
| `LAST_DAY` | Returns date of last day of the month | `LAST_DAY(SYSDATE)` |
| `TRUNC(date)` | Truncates date to beginning of unit | `TRUNC(SYSDATE, 'MM')` = 1st of month |
| `ROUND(date)` | Rounds date to nearest unit | `ROUND(SYSDATE, 'MONTH')` |
| `EXTRACT()` | Extracts date part (YEAR, MONTH, etc.) | `EXTRACT(YEAR FROM SYSDATE)` |

## Topic 5 - Using Conversion Functions and Conditional Expressions

Subtopics:

* Applying the NVL, NULLIF, and COALESCE functions to data
    
* Understanding implicit and explicit data type conversion
    
* Using the TO\_CHAR, TO\_NUMBER, and TO\_DATE conversion functions
    
* Nesting multiple functions
    

### Applying the NVL, NULLIF, and COALESCE functions to data

* `NVL(expression, replacement_value)` → Replaces NULL with the given value
    
* `NVL2(expression, replacement_notnull, replancement_null)` → if expression NULL returns replacement\_null, otherwise replacement\_notnull
    
* `NULLIF(expr1, expr2)` → Returns NULL if expr1 = expr2, otherwise, returns expr1
    
* `COALESCE(expr1, expr2, ..., exprN)` → Returns the first non-NULL expression
    

NVL, NVL2, NULLIF, and COALESCE all need same data types in their arguments.

### Understanding implicit and explicit data type conversion

* Implicit conversion happens when Oracle converts between data types behind the scenes.
    
* Explicit conversion happens you control it with functions (see next subtopic)
    

### Using the TO\_CHAR, TO\_NUMBER, and TO\_DATE conversion functions

| **Function** | **Converts...** | **Example** |
| --- | --- | --- |
| `TO_CHAR()` | Date or number → String | `TO_CHAR(SYSDATE, 'DD-MON-YYYY')` `TO_CHAR('1023.95', '$9,999')` |
| `TO_NUMBER()` | String → Number | `TO_NUMBER('12345')` |
| `TO_DATE()` | String → Date | `TO_DATE('2025-04-14', 'YYYY-MM-DD')` |

Note: `TO_CHAR('1023.95', '$9,999')` will result in $1,024 (it rounds, not truncates).

Note: `TO_DATE` does *not* always require the second parameter (the format mask). If the string matches the session's `NLS_DATE_FORMAT`, then you can omit it.

You don’t need always TO\_DATE() function to convert a string to a date, you can also use date literal:

```sql
-- This is valid Oracle SQL syntax and will return a DATE value
SELECT DATE '2025-01-01' FROM DUAL;
```

* It is a shortcut for creating a `DATE` value **without using** `TO_DATE()`
    
* The format must be exactly `'YYYY-MM-DD'`
    
* The time component defaults to `00:00:00`
    
* Works only with format `'YYYY-MM-DD'`
    
* You cannot use other formats like `'DD-MM-YYYY'` with `DATE '...'`
    
* For anything more complex (like including time), you still need `TO_DATE`
    

### Nesting multiple functions

You can nest functions (use one function as the input of another).

```sql
SELECT TO_CHAR(NVL(commission_pct, 0)) AS commission_str 
FROM employees;
```

## Topic 6 - Reporting Aggregated Data Using Group Functions

Subtopics:

* Using Group Functions
    
* Creating Groups of Data
    
* Restricting Group Results
    

### Using Group Functions

Common Oracle Group Functions: `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()`, I will not go in depth.

### Creating Groups of Data

This is the `GROUP BY` clause, I will not go in depth.

### Restricting Group Results

This is the `HAVING` clause, I will not go in depth.

## Topic 7 - Displaying Data from Multiple Tables

Subtopics:

* Using Various Types of Joins
    
* Using OUTER joins
    
* Using Self-joins
    
* Using Non equijoins
    
* Understanding and Using Cartesian Products
    

### Using Various Types of Joins

Note: in Oracle Joins the ON (or USING) clause is mandatory, you cannot use WHERE for the JOIN clause.

| **Join Type** | **Description** |
| --- | --- |
| INNER JOIN | Returns only matching rows from both tables |
| OUTER JOIN | Returns matching rows plus non-matching rows |
| SELF JOIN | Joins a table to itself |
| NON-EQUIJOIN | Joins on a range or inequality |
| CROSS JOIN | Returns all combinations (Cartesian product) |
| NATURAL JOIN | Join automatically on columns with the same name (supported in Oracle, but rarely used in real projects) |
| ANTI JOIN | Used in Oracle internally (or explicitly with NOT EXISTS, MINUS, etc.) |
| SEMI JOIN | Like EXISTS—Oracle can optimize subqueries into semi joins |
| HASH JOIN, MERGE JOIN, NESTED LOOPS JOIN | These are execution strategies (used in query plans), not SQL join types you write directly |

### Using OUTER joins

`LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`

OUTER JOINs return matching rows plus non-matching rows from one or both tables, I will not go in depth.

### Using Self-joins

A self-join is a regular join where a table is joined to itself.

Used when rows in a table are related to other rows in the same table (e.g. employees and managers).

```sql
SELECT e.first_name AS employee, m.first_name AS manager
FROM employees e
JOIN employees m ON e.manager_id = m.employee_id;
```

### Using Non equijoins

Non-equijoins are joins where the condition is not based on equality (=), but on ranges or other comparisons.

Often used in cases like salary grade bands, time intervals, etc.

```sql
SELECT e.employee_id, s.grade_level
FROM employees e
JOIN salary_grades s ON e.salary BETWEEN s.min_salary AND s.max_salary;
```

### Understanding and Using Cartesian Products

A Cartesian product occurs when you don’t specify a join condition—you get every combination of rows from both tables.

Not very useful apart from generating test data in my experience.

<mark>ADD A NOTE ABOUT ORACLE JOIN SYNTAX!</mark>

## Topic 8 - Using Subqueries to Solve Queries

Subtopics:

* Using Single Row Subqueries
    
* Using Multiple Row Subqueries
    
* Update and delete rows using correlated subqueries
    

### Using Single Row Subqueries

A single-row subquery returns only one row and one or more columns. Usually used with comparison operators.

```sql
SELECT first_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

A single row subquery:

* can be nested
    
* can be used in the VALUES clause of an INSERT statement
    
* if returns zero rows it evaluates to NULL
    
* cannot be used directly inside a GROUP BY clause
    

### Using Multiple Row Subqueries

A multiple-row subquery returns more than one row. often used with operators like: `IN`, `ANY` / `SOME`, `ALL`, `EXISTS`

```sql
SELECT first_name, salary
FROM employees
WHERE salary > ANY (
  SELECT salary
  FROM employees
  WHERE job_id = 'IT_PROG'
);
```

* `> ANY` = greater than the lowest salary from the subquery
    
* `> ALL` = greater than the highest
    
* `<> ANY` returns true if the value is different from at least one of the values in the list — not all, just one.
    

### Update and delete rows using correlated subqueries

A correlated subquery is a subquery that depends on the outer query, it’s re-evaluated for each row of the outer query.

```sql
-- Update employee commissions to 0 if their salary is below the department average
UPDATE employees e
SET commission_pct = 0
WHERE salary < (
  SELECT AVG(salary)
  FROM employees
  WHERE department_id = e.department_id
);

-- Delete employees who have the lowest salary in their department
DELETE FROM employees e
WHERE salary = (
  SELECT MIN(salary)
  FROM employees
  WHERE department_id = e.department_id
);
```

## Topic 9 - Using SET Operators

Subtopics:

* Using The INTERSECT operator
    
* Using The MINUS operator
    
* Using The UNION and UNION ALL operators
    
* Matching the SELECT statements
    
* Using the ORDER BY clause in set operations
    

### Using The INTERSECT, MINUS, UNION and UNION ALL operators

Set operators let you combine the result sets of two or more SELECT statements.

| **Set Operator** | **What it Does** |
| --- | --- |
| `UNION` | Combines results and removes duplicates |
| `UNION ALL` | Combines results and keeps duplicates |
| `INTERSECT` | Returns only common rows in both result sets |
| `MINUS` | Returns rows from the first query only that are not in the second |

Some notes:

* In case there are different Set operators in the same query, this is the precedence: Oracle follows operator precedence for set operators: INTERSECT (evaluated first) &gt; UNION / MINUS &gt; UNION ALL
    
* Oracle implicitly converts CHAR to VARCHAR2 in SET operations. The resulting column will have the length of the longest value, not the original fixed length.
    
* Set operators are not valid on some types, e.g., BLOB
    

### Matching the SELECT statements

Rules:

* Same number of columns
    
* Same data types (or implicitly convertible)
    
* The columns do not need the same names
    

### Using the ORDER BY clause in set operations

The ORDER BY clause must appear once, at the end of the entire statement, not in individual SELECTs.

## Topic 10 - Managing Tables using DML statements

Subtopics:

* Managing Database Transactions
    
* Controlling transactions
    
* Perform Insert, Update and Delete operations
    
* Performing multi table Inserts
    
* Performing Merge statements
    

### Managing Database Transactions

A transaction is a logical unit of work that consists of one or more DML operations.

* A transaction starts with the first DML statement.
    
* A transaction ends when you:
    
    * COMMIT (make changes permanent)
        
    * ROLLBACK (undo changes)
        
    * Disconnect from the database
        

Note that this is only related to DML operations, DDL statements (like CREATE, ALTER, DROP) are auto-committing.

Note that:

* Executing any DDL (CREATE, DROP, ALTER, etc.) implicitly commits the current transaction before and after the DDL runs.
    
* When you exit SQL\*Plus cleanly (without explicitly rolling back), Oracle automatically commits any active transaction.
    

### Controlling transactions

Oracle provides TCL (Transaction Control Language) commands:

| **Command** | **Description** |
| --- | --- |
| `COMMIT` | Saves all changes in the current transaction |
| `ROLLBACK` | Undoes all changes in the current transaction |
| `SAVEPOINT name` | Marks a point you can roll back to |
| `ROLLBACK TO name` | Undoes changes back to a savepoint |

```sql
INSERT INTO employees VALUES (...);
SAVEPOINT before_bonus;
UPDATE employees SET salary = salary + 500;
ROLLBACK TO before_bonus;
COMMIT;
```

You can also write `ROLLBACK TO SAVEPOINT before_bonus;`

### Perform Insert, Update and Delete operations

No differences with T-SQL and standard SQL, so I’m not covering this one

### Performing multi table Inserts

Used to insert the same data into multiple tables, a feature unique to Oracle.

Only works in INSERT ALL and INSERT FIRST statements, typically in combination with a SELECT.

```sql
-- Inserts into all specified tables regardless of conditions
INSERT ALL
  INTO hr_archive VALUES (...)
  INTO hr_backup VALUES (...)
SELECT * FROM employees WHERE department_id = 90;

-- Conditionally insert each row from a query into one (and only one) target table, based on the first matching WHEN condition
INSERT FIRST
  WHEN salary > 10000 THEN INTO high_salary VALUES (...)
  WHEN salary <= 10000 THEN INTO low_salary VALUES (...)
SELECT * FROM employees;

-- More complex example with ELSE condition
INSERT ALL
  WHEN amount > 800 THEN
    INTO high_value_orders (order_id, customer_name, amount) VALUES (order_id, customer_name, amount)
    INTO premium_customers (order_id, customer_name) VALUES (order_id, customer_name)
  WHEN amount BETWEEN 500 AND 800 THEN
    INTO premium_customers (order_id, customer_name) VALUES (order_id, customer_name)
  ELSE
    INTO regular_orders (order_id, customer_name, amount) VALUES (order_id, customer_name, amount)
SELECT order_id, customer_name, amount
FROM orders_staging;

-- Unconditional multitable insert, other syntax possible
INSERT ALL
  INTO sales_2024 (prod_id, qty, amount)
  INTO sales_audit (prod_id, qty)
SELECT prod_id, qty, amount
FROM sales_source;

-- Conditional multitable insert, other syntax possible
INSERT ALL
  WHEN amount > 1000 THEN
    INTO big_sales (prod_id, qty, amount)
  WHEN amount <= 1000 THEN
    INTO small_sales (prod_id, qty, amount)
SELECT prod_id, qty, amount
FROM sales_source;
```

### Performing Merge statements

MERGE combines INSERT and UPDATE logic.

Use case: When you want to update a row if it exists or insert a new row if it doesn't.

```sql
MERGE INTO employees e
USING new_employees n
ON (e.employee_id = n.employee_id)
WHEN MATCHED THEN
  UPDATE SET e.salary = n.salary
WHEN NOT MATCHED THEN
  INSERT (employee_id, first_name, salary)
  VALUES (n.employee_id, n.first_name, n.salary);
```

There is not `WHEN NOT MATCHED BY SOURCE THEN DELETE` condition that we have in T-SQL.

You can also have a DELETE if you need but ONLY after UPDATE (mandatory after WHEN MATCHED THEN) and INSERT (mandatory after WHEN NOT MATCHED THEN).

## Topic 11 - Managing Indexes, Synonyms and Sequences

Subtopics:

* Managing Indexes
    
* Managing Synonyms
    
* Managing Sequences
    

### Managing Indexes

Types of Indexes in Oracle:

| **Type** | **Description** | **Code** |
| --- | --- | --- |
| B-tree index (default) | Optimized for high-cardinality columns (many distinct values) | `CREATE INDEX emp_lastname_idx ON employees (last_name);` |
| Bitmap index | Best for low-cardinality columns (few distinct values, e.g., gender). Usually used only in read-heavy environments like data warehouses. | `CREATE BITMAP INDEX emp_gender_idx ON employees (gender);` |
| Unique index | Enforces uniqueness on one or more columns | `CREATE UNIQUE INDEX emp_email_uq ON employees (email);` |
| Function-based index | Index based on expressions or functions | `CREATE INDEX emp_upper_lastname_idx ON employees (UPPER(last_name));` |
| Composite index | Index on multiple columns | `CREATE INDEX emp_dept_job_idx ON employees (department_id, job_id);` |

* Indexes improve SELECT performance, but can slow down INSERT/UPDATE/DELETE because they also need to be updated.
    
* Oracle automatically creates indexes for:
    
    * Primary keys
        
    * Unique constraints (unless there’s a unique index already on the column, in that case Oracle can reuse it)
        
* To drop an index: `DROP INDEX emp_name_idx;`
    
* There are also Invisible Indexes in Oracle: by default, the optimizer ignores invisible indexes unless you force the use of them in the query.
    

### Managing Synonyms

A synonym is an alias or shortcut for a database object (like a table, view, sequence, or procedure). It allows users to reference objects without using schema names for example. A synonym can have a synonym (synonym chaining).

Types of synonyms:

* Public synonym: Visible to all users
    
    * To create: `CREATE PUBLIC SYNONYM emp FOR hr.employees;`
        
    * To drop: `DROP PUBLIC SYNONYM emp;`
        
    * To create a public synonym, you must have the `CREATE PUBLIC SYNONYM` system privilege.
        
* Private synonym: Visible only to the user who created it
    
    * To create: `CREATE SYNONYM emp FOR hr.employees;`
        
    * To drop: `DROP SYNONYM emp;`
        
    * To create a private synonym in your own schema, you must have the `CREATE SYNONYM` system privilege.
        
    * To create a private synonym in another user's schema, you must have the `CREATE ANY SYNONYM` system privilege.
        

### Managing Sequences

A sequence is a database object that generates numeric values, typically used to create unique primary key values.

```sql
CREATE SEQUENCE emp_seq
START WITH 1000
INCREMENT BY 1
MAXVALUE 100000
NOCACHE
NOCYCLE;
```

| **Option** | **Description** |
| --- | --- |
| `START WITH` | First number in the sequence |
| `INCREMENT BY` | How much to increase each time |
| `MAXVALUE` / `MINVALUE` | If we don’t specify MAXVALUE, Oracle sets it by default to 28,000,000,000,000,000,000 (10^28 - 1), so large that the sequence won’t reach it under normal usage. |
| `CACHE` n / `NOCACHE` | CACHE 20 is default. CACHE improve performance by preallocating numbers |
| `CYCLE` / `NOCYCLE` | NOCYCLE is default one and prevents restarting from `START WITH`. Only matters if there’s a `MAXVALUE` or `MINVALUE` set. With NOCYCLE, after MAXVALUE is reached we will receive an error. |

```sql
-- Use the sequence
emp_seq.NEXTVAL

-- Current value (only after NEXTVAL is used in session)
emp_seq.CURRVAL

-- Example
INSERT INTO employees (employee_id, first_name)
VALUES (emp_seq.NEXTVAL, 'Mia');

-- Drop sequence
DROP SEQUENCE emp_seq;
```

NOTE: Sequences in Oracle are not transactional — they don’t roll back. Once you call `SELECT emp_seq.NEXTVAL FROM dual;` you have consumed that value permanently, even if:

* You didn’t use it in an `INSERT`
    
* The statement was part of a `ROLLBACK`
    
* You just selected it to “see what’s next”
    

## Topic 12 - Use DDL to manage tables and their relationships

Subtopics:

* Describing and Working with Tables
    
* Describing and Working with Columns and Data Types
    
* Creating and dropping tables
    
* Dropping columns and setting column UNUSED
    
* Truncating tables
    
* Creating and using Temporary Tables
    
* Creating and using external tables
    
* Managing Constraints
    

### Describing and Working with Tables

Two ways to view table structure

```sql
-- 1
DESCRIBE employees;

-- 2
SELECT column_name, data_type, data_length
FROM user_tab_columns
WHERE table_name = 'EMPLOYEES';
```

The DESCRIBE command (you can also use DESC):

* it’s a client command provided by Oracle tools like SQL\*Plus, SQLcl, and even Oracle SQL Developer in a slightly different form.
    
* DESCRIBE shows:
    
    * Column names
        
    * Data types
        
    * Length/precision/scale
        
    * Whether NULL values are allowed
        
* You can DESCRIBE:
    
    * Tables
        
    * Views
        
    * Synonyms
        
    * Types (including object types)
        
* You cannot DESCRIBE:
    
    * Results of a query
        
    * PL/SQL blocks
        
    * Inline views (subqueries)
        

### Describing and Working with Columns and Data Types

| **Data Type** | **Type** | **Description** |
| --- | --- | --- |
| `VARCHAR2(n)` | Character | Variable-length string (max 32,767 bytes) |
| `CHAR(n)` | Character | Fixed-length string |
| `NCHAR(n)` | Character (Unicode) | Fixed-length Unicode string |
| `NVARCHAR2(n)` | Character (Unicode) | Variable-length Unicode string |
| `NUMBER(p,s)` | Numeric | Fixed/float number with precision and scale |
| `FLOAT` | Numeric (approximate) | Floating-point number |
| `BINARY_FLOAT` | Numeric (approximate) | 32-bit floating-point number |
| `BINARY_DOUBLE` | Numeric (approximate) | 64-bit floating-point number |
| `DATE` | Date/Time | Date + time (no timezone) |
| `TIMESTAMP` | Date/Time | Date + time + fractional seconds |
| `TIMESTAMP WITH TIME ZONE` | Date/Time | Timestamp with timezone info |
| `TIMESTAMP WITH LOCAL TIME ZONE` | Date/Time | Normalized to DB timezone |
| `INTERVAL YEAR TO MONTH` | Interval | Span of time in years and months |
| `INTERVAL DAY TO SECOND` | Interval | Span of time in days, hours, minutes, seconds |
| `BLOB` | LOB | Binary large object (e.g., image) |
| `CLOB` | LOB | Large character object (up to 4GB text) |
| `BFILE` | External LOB | Binary file stored outside the database |
| `RAW(n)` | Binary | Raw binary data (max 2000 bytes) |

### Creating and Dropping Tables

Two main ways to create a table

```sql
-- 1
CREATE TABLE departments (
  department_id NUMBER PRIMARY KEY,
  department_name VARCHAR2(50) NOT NULL
);

-- 2 - Based on a query
CREATE TABLE recent_hires AS
SELECT * FROM employees WHERE hire_date > SYSDATE - 30;
```

You can restore a table if you accidentally dropped it by using FLASHBACK TABLE command

```sql
FLASHBACK TABLE table_name TO BEFORE DROP;

-- To see what’s in your Recycle Bin:
SHOW RECYCLEBIN;
-- or
SELECT * FROM USER_RECYCLEBIN;
```

In DROP table you can use the PURGE clause, in this case:

* The table does not go to the Recycle Bin
    
* You cannot use `FLASHBACK TABLE TO BEFORE DROP`
    
* Cannot be rolled back
    

```sql
DROP TABLE departments PURGE;
```

Oracle supports virtual columns:

```sql
CREATE TABLE employees (
  first_name  VARCHAR2(100),
  last_name   VARCHAR2(100),
  full_name   VARCHAR2(200)
    GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
);
```

Something more about virtual columns:

* A virtual column CAN be indexed
    
* A virtual column CAN have a data type explicitly specified
    
* A virtual column CANNOT be referenced in the column expression of another virtual column
    

### Dropping columns and setting column UNUSED

```sql
-- Drop a column
ALTER TABLE employees DROP COLUMN bonus;

-- Drop more columns simultaneusly
ALTER TABLE employees DROP (bonus, salary);

-- Mark column as UNUSED (like a logical drop)
ALTER TABLE employees SET UNUSED (bonus);

-- Drop all unused columns (physical removal)
ALTER TABLE employees DROP UNUSED COLUMNS;

-- If the column participates in constraints, you must use CASCADE CONSTRAINTS
ALTER TABLE employees SET UNUSED (LastName) CASCADE CONSTRAINTS;
```

* Setting columns as UNUSED is irreversible, you need to recreate the table
    
* Unused columns retain their data until they are dropped
    
* Once a column has been set to unused, a new column with the same name can be added to the table
    
* You can set an indexed column as unused, but Oracle will automatically drop the index on that column
    
* You cannot see unused column names in the data dictionary
    
* `CASCADE CONSTRAINTS` must be specified when setting a column to unused if that column is referenced in a constraint on another column
    

### Truncating tables

* Removes all rows quickly (no undo logging) - Much faster than DELETE command
    
* Cannot be rolled back
    
* Resets high water mark
    

```sql
TRUNCATE TABLE employees;
```

### Creating and using Temporary Tables

Used to store session-specific or transaction-specific data.

```sql
CREATE GLOBAL TEMPORARY TABLE temp_orders (
  order_id NUMBER,
  amount NUMBER
) ON COMMIT DELETE ROWS;
```

* `ON COMMIT DELETE ROWS`: clears data after each transaction
    
* `ON COMMIT PRESERVE ROWS`: clears data at session end
    

Some notes about Temporary tables:

* Despite the word "GLOBAL", the behavior of the data is session-specific or transaction-specific, not globally shared. It refers to the fact that the table structure is global so table definition is available to multiple sessions, but the data is private to each session or transaction. Even INSERT if committed, other sessions cannot see it.
    
* You cannot define a foreign key constraint on a global temporary table — neither as parent nor child.
    
* You can create indexes (both unique and non-unique) on them.
    
* You can reference a GTT in a view's query. However, be cautious: the view will return no rows unless the session has populated the GTT.
    
* You can create a public synonym for a GTT like any other table.
    
* You can create triggers on GTTs, including BEFORE INSERT, AFTER DELETE, etc.
    
* If you don’t specify anything the default is `ON COMMIT DELETE ROWS`. This means that if you do an INSERT INTO and then COMMIT, the rows are deleted and not inserted!
    

### Creating and using external tables

Used to query data stored outside Oracle (e.g., flat files in directories).

TYPE and LOCATION are the only mandatory clauses for external tables. In type we have to choose the access driver, more common are ORACLE\_LOADER and ORACLE\_DATAPUMP:

| **Feature** | **ORACLE\_LOADER** | **ORACLE\_DATAPUMP** |
| --- | --- | --- |
| File type | Text (CSV, TSV, fixed-width) | Binary (Data Pump format) |
| Access | Read-only | Read and write |
| Speed/performance | Slower (text parsing) | Faster (binary format) |
| Editability | Human-editable | Binary, not editable |
| Use cases | Import flat files | Unload/import Oracle data |
| Format specification | Access parameters (field defs) | Inferred from table structure |

* When using the ORACLE\_DATAPUMP access driver, you can populate the dump file (which the external table will read from) by selecting data from another external table or a regular Oracle table (whose rows are stored in blocks).
    
* The ORACLE\_DATAPUMP access driver allows external tables to create and use dump files. These dump files can be moved and reused across databases, as long as the structure and external table definitions are compatible.
    

```sql
-- ORACLE_LOADER access driver
CREATE TABLE ext_employees (
  employee_id   NUMBER,
  first_name    VARCHAR2(50),
  salary        NUMBER
)
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY ext_dir
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY NEWLINE
    FIELDS TERMINATED BY ','
  )
  LOCATION ('employees.csv')
)
REJECT LIMIT UNLIMITED;

-- ORACLE_DATAPUMP access driver
CREATE TABLE ext_emp
ORGANIZATION EXTERNAL
(
  TYPE ORACLE_DATAPUMP
  DEFAULT DIRECTORY dpump_dir
  LOCATION ('emp_data.dmp')
)
AS
SELECT * FROM emp;
```

Requires a DIRECTORY object and read access.

```sql
--Create a Directory Object (done by DBA or user with privileges)
CREATE OR REPLACE DIRECTORY ext_data_dir AS '/u01/app/oracle/external_files';

-- Grant Access to the Directory
GRANT READ ON DIRECTORY ext_data_dir TO hr;
```

This tells Oracle: “The directory on disk is /u01/app/oracle/external\_files.” - This is a physical directory on the Oracle server, not on your PC.

* The definition (column names, types, location of the file, access driver, etc.) of external tables is stored in the Oracle data dictionary.
    
* You cannot use INSERT, UPDATE, DELETE, or MERGE on external tables. They are read-only.
    
* You cannot create indexes on external tables because Oracle doesn't store the data internally.
    

### Managing Constraints

Constraints enforce data integrity rules.

Constraints types:

| **Constraint Type** | **Description** | **Keyword** |
| --- | --- | --- |
| Primary key | Uniquely identifies rows | `PRIMARY KEY` |
| Foreign key | Enforces referential integrity | `FOREIGN KEY` |
| Unique | Prevents duplicate values | `UNIQUE` |
| Not null | Disallows NULL values | `NOT NULL` |
| Check | Enforces a condition | `CHECK` |

```sql
-- Add contraint
ALTER TABLE employees ADD CONSTRAINT emp_email_uk UNIQUE (email);

-- Disable/Enable
ALTER TABLE employees DISABLE CONSTRAINT emp_email_uk;
ALTER TABLE employees ENABLE CONSTRAINT emp_email_uk;

-- Drop
ALTER TABLE employees DROP CONSTRAINT emp_email_uk;

-- NOT NULL
CREATE TABLE employees (
  employee_id NUMBER NOT NULL,
  first_name  VARCHAR2(50)
);

-- UNIQUE
CREATE TABLE employees (
  email VARCHAR2(100) UNIQUE
);

-- UNIQUE named
CREATE TABLE employees (
  email VARCHAR2(100),
  CONSTRAINT emp_email_uk UNIQUE (email)
);

-- PRIMARY KEY
CREATE TABLE departments (
  department_id NUMBER PRIMARY KEY,
  department_name VARCHAR2(100)
);

-- PRIMARY KEY named
CREATE TABLE departments (
  department_id NUMBER,
  department_name VARCHAR2(100),
  CONSTRAINT dept_pk PRIMARY KEY (department_id)
);

--FOREIGN KEY
CREATE TABLE employees (
  department_id NUMBER REFERENCES departments(department_id)
);

-- FOREIGN KEY named
CREATE TABLE employees (
  department_id NUMBER,
  CONSTRAINT fk_dept_id
    FOREIGN KEY (department_id)
    REFERENCES departments(department_id)
);

-- Disable with Cascade to disable also related foreign keys
ALTER TABLE departments DISABLE CONSTRAINT dept_pk CASCADE;

-- CHECK constraint
CREATE TABLE employees (
  salary NUMBER CHECK (salary > 0)
);

-- CHECK named
CREATE TABLE employees (
  salary NUMBER,
  CONSTRAINT salary_positive CHECK (salary > 0)
);
```

## Topic 13 - Managing Views

```sql
-- Create a View
CREATE VIEW vw_emp_dept AS
SELECT e.employee_id, e.first_name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- Create/Modify a view
CREATE OR REPLACE VIEW vw_emp AS
SELECT employee_id, salary
FROM employees
WHERE salary > 5000;

-- Drop a view
DROP VIEW vw_emp_dept;
```

Oracle allows DML (INSERT, UPDATE, DELETE) operations on views only if:

* The view is based on a single table
    
* The view doesn’t use:
    
    * Aggregates (`SUM`, `AVG`, etc.)
        
    * `GROUP BY`, `DISTINCT`, `UNION`, etc.
        
    * `ROWNUM`, `CONNECT BY`, etc.
        
* All columns being updated must be directly mapped to the base table
    

```sql
UPDATE vw_emp
SET salary = salary + 1000
WHERE employee_id = 101;
```

`WITH CHECK OPTION` prevents users from modifying rows outside the view’s WHERE clause.

```sql
CREATE OR REPLACE VIEW vw_high_salary AS
SELECT employee_id, salary
FROM employees
WHERE salary > 10000
WITH CHECK OPTION;

-- Now this will fail because 9000 doesn’t satisfy the WHERE salary > 10000 condition
UPDATE vw_high_salary 
SET salary = 9000
WHERE employee_id = 105;
```

`WITH READ ONLY` makes the view completely read-only (no DML allowed).

```sql
CREATE VIEW vw_readonly AS
SELECT * FROM employees
WITH READ ONLY;
```

You can create a view with `FORCE` even if base tables do not yet exist: the view will be created in an invalid state and becomes valid once the table is created.

```sql
CREATE FORCE VIEW my_view AS SELECT * FROM missing_table;
```

## Topic 14: Controlling User Access

Subtopics:

* Differentiating system privileges from object privileges
    
* Granting privileges on tables
    

Some notes about privileges:

* Owners of schema objects can grant privileges on their own objects to others.
    
* Granting system privileges requires `GRANT ANY PRIVILEGE`.
    

### System Privileges

Allow a user to perform actions on the database level.

| **Privilege** | **What It Allows** |
| --- | --- |
| `CREATE TABLE` | Create tables in the user's own schema |
| `CREATE USER` | Create other users |
| `DROP ANY TABLE` | Drop any table in any schema |
| `SELECT ANY TABLE` | Select from any table in the database |
| `ALTER SYSTEM` | Change instance-wide settings |
| `CREATE SESSION` | Log in to the database |

```sql
GRANT CREATE TABLE, CREATE VIEW TO mia;
GRANT CREATE SESSION TO mia;

--WITH ADMIN OPTION allows the grantee to grant system privileges to others
GRANT CREATE USER TO mia WITH ADMIN OPTION;

-- Revoke system privileges
REVOKE CREATE TABLE FROM mia;
```

### Object Privileges

Allow a user to perform actions on specific database objects.

| **Privilege** | **Applies To** | **Allows the user to:** |
| --- | --- | --- |
| `SELECT` | Table/View/Sequences | Read data (use `CURRVAL` and `NEXTVAL` from sequences) |
| `INSERT` | Table/View | Insert new rows |
| `UPDATE` | Table/View | Modify existing rows |
| `DELETE` | Table/View | Remove rows |
| `REFERENCES` | Table | Use columns in foreign key constraints |
| `EXECUTE` | Procedure/Function/Package | Call a stored procedure or a function |
| `ALTER` | Table/Sequence | Change the structure |

```sql
GRANT SELECT, INSERT ON employees TO mia;
GRANT EXECUTE ON calculate_bonus TO ceci;

-- WITH GRANT OPTION allows the grantee to pass the privilege on to others
GRANT SELECT ON employees TO mia WITH GRANT OPTION;

-- You can grant to update only some fields
GRANT UPDATE (title, address) ON employees TO mia;

-- Revoke object privileges
REVOKE SELECT ON employees FROM ceci;
```

## Topic 15 - **Managing Objects with Data Dictionary Views**

The Data Dictionary is a set of read-only tables and views maintained by Oracle that store information about the database structure, such as:

* Users and roles
    
* Tables, views, indexes
    
* Constraints and privileges
    
* Sequences, synonyms, procedures
    
* Storage, tablespaces, etc.
    

You query the dictionary using special views:

| **View Prefix** | **Scope** | **Description** |
| --- | --- | --- |
| `USER_` | Objects owned by current user | What you own |
| `ALL_` | Objects you have access to (your own + others) | What you can see |
| `DBA_` | All objects in the database (requires `DBA` role) | What DBAs can manage |
| `V$` | Dynamic performance views | Runtime stats on sessions, memory, etc. |

Oracle Data Dictionary View Families:

| **USER\_ View** | **ALL\_ View** | **DBA\_ View** | **Description** |
| --- | --- | --- | --- |
| `USER_TABLES` | `ALL_TABLES` | `DBA_TABLES` | Lists tables owned by / accessible to / existing in DB |
| `USER_TAB_COLUMNS` | `ALL_TAB_COLUMNS` | `DBA_TAB_COLUMNS` | Lists columns in those tables |
| `USER_CONSTRAINTS` | `ALL_CONSTRAINTS` | `DBA_CONSTRAINTS` | Constraints (PK, FK, check, etc.) |
| `USER_CONS_COLUMNS` | `ALL_CONS_COLUMNS` | `DBA_CONS_COLUMNS` | Columns involved in constraints |
| `USER_INDEXES` | `ALL_INDEXES` | `DBA_INDEXES` | Index definitions |
| `USER_VIEWS` | `ALL_VIEWS` | `DBA_VIEWS` | View definitions |
| `USER_SEQUENCES` | `ALL_SEQUENCES` | `DBA_SEQUENCES` | Sequence definitions |
| `USER_SYNONYMS` | `ALL_SYNONYMS` | `DBA_SYNONYMS` | Synonym definitions |
| `USER_OBJECTS` | `ALL_OBJECTS` | `DBA_OBJECTS` | All objects (tables, indexes, views, etc.) |
| `USER_TAB_PRIVS` | `ALL_TAB_PRIVS` | `DBA_TAB_PRIVS` | Table-level object privileges |
| `USER_COL_PRIVS` | `ALL_COL_PRIVS` | `DBA_COL_PRIVS` | Column-level privileges |

Most used queries for data dictionary views:

| **Purpose** | **View** | **Example Query** |
| --- | --- | --- |
| List your tables | `USER_TABLES` | `SELECT table_name FROM user_tables;` |
| List accessible tables | `ALL_TABLES` | `SELECT owner, table_name FROM all_tables WHERE table_name = 'EMPLOYEES';` |
| List all tables in DB | `DBA_TABLES` | `SELECT owner, table_name FROM dba_tables;` |
| List columns in a table | `USER_TAB_COLUMNS` | `SELECT column_name, data_type FROM user_tab_columns WHERE table_name = 'EMPLOYEES';` |
| List column constraints | `USER_CONS_COLUMNS` | `SELECT constraint_name, column_name FROM user_cons_columns WHERE table_name = 'EMPLOYEES';` |
| List table constraints | `USER_CONSTRAINTS` | `SELECT constraint_name, constraint_type FROM user_constraints WHERE table_name = 'EMPLOYEES';` |
| List PK/FK columns | `USER_CONS_COLUMNS` | `SELECT * FROM user_cons_columns WHERE constraint_name = 'EMP_PK';` |
| List indexes | `USER_INDEXES` | `SELECT index_name, table_name FROM user_indexes;` |
| List indexed columns | `USER_IND_COLUMNS` | `SELECT index_name, column_name FROM user_ind_columns WHERE table_name = 'EMPLOYEES';` |
| List your views | `USER_VIEWS` | `SELECT view_name FROM user_views;` |
| Get view SQL text | `USER_VIEWS` | `SELECT text FROM user_views WHERE view_name = 'EMP_VIEW';` |
| List your sequences | `USER_SEQUENCES` | `SELECT sequence_name, last_number FROM user_sequences;` |
| List your synonyms | `USER_SYNONYMS` | `SELECT synonym_name, table_name FROM user_synonyms;` |
| List all public synonyms | `ALL_SYNONYMS` | `SELECT * FROM all_synonyms WHERE table_name = 'EMPLOYEES';` |
| List all your objects | `USER_OBJECTS` | `SELECT object_name, object_type FROM user_objects;` |
| List all accessible objects | `ALL_OBJECTS` | `SELECT owner, object_name FROM all_objects WHERE object_type = 'TABLE';` |
| Table privileges you granted | `USER_TAB_PRIVS_MADE` | `SELECT * FROM user_tab_privs_made;` |
| Table privileges granted to you | `USER_TAB_PRIVS` | `SELECT * FROM user_tab_privs;` |
| Column-level privileges | `USER_COL_PRIVS` | `SELECT * FROM user_col_privs;` |
| See current sessions | `V$SESSION` | `SELECT sid, username FROM v$session WHERE username IS NOT NULL;` |
| View currently executed SQL statements | `V$SQL` | `SELECT sql_text FROM v$sql WHERE rownum < 5;` |

## Topic 16 - Managing Data in Different Time Zones

Subtopics:

* Working with CURRENT\_DATE, CURRENT\_TIMESTAMP,and LOCALTIMESTAMP
    
* Working with INTERVAL data types
    

### Working with CURRENT\_DATE, CURRENT\_TIMESTAMP,and LOCALTIMESTAMP

These built-in functions return current date and time, but each behaves slightly differently depending on your session time zone and whether time zone info is included.

| **Function** | **Data Type Returned** | **Time Zone Aware?\*** | **Based On** | **Example Output** |
| --- | --- | --- | --- | --- |
| `SYSDATE` | DATE | No | DB server time | 14-MAY-25 17:45:01 |
| `CURRENT_DATE` | DATE | No | Session time zone | 14-MAY-25 18:45:01 |
| `SYSTIMESTAMP` | TIMESTAMP WITH TIME ZONE | Yes | DB server time zone | 14-MAY-25 17.45.01.123456 +01:00 |
| `CURRENT_TIMESTAMP` | TIMESTAMP WITH TIME ZONE | Yes | Session time zone | 14-MAY-25 18.45.01.123456 +02:00 |
| `LOCALTIMESTAMP` | TIMESTAMP | No (no TZ info) | Session time zone | 14-MAY-25 18.45.01.123456 |

\* Time Zone Aware means the returned TIMESTAMP includes time zone info (e.g., +02:00, UTC) and Oracle stores and compares the timestamp with the zone in mind.

```sql
SELECT 
  SYSDATE,
  CURRENT_DATE,
  CURRENT_TIMESTAMP,
  LOCALTIMESTAMP,
  SYSTIMESTAMP
FROM dual;

-- Set your session Time Zone
ALTER SESSION SET TIME_ZONE = 'Europe/Rome';
```

Oracle supports named time zones (`'UTC'`, `'US/Eastern'`, etc.) and numeric offsets (`'+02:00'`).

### Working with INTERVAL data types

Oracle provides INTERVAL types to store durations, not points in time.

| **Interval Type** | **Description** | **Example Literal** |
| --- | --- | --- |
| `INTERVAL YEAR TO MONTH` | Duration in years and months | `INTERVAL '2-6' YEAR TO MONTH` |
| `INTERVAL DAY TO SECOND` | Duration in days, hours, mins, secs | `INTERVAL '5 12:30:15' DAY TO SECOND` |

```sql
-- Add 3 months to SYSDATE
SELECT SYSDATE + INTERVAL '3' MONTH FROM dual;

-- Subtract 2 years and 6 months
SELECT SYSDATE - INTERVAL '2-6' YEAR TO MONTH FROM dual;

-- Add 2 days and 5 hours
SELECT SYSDATE + INTERVAL '2 5:00:00' DAY TO SECOND FROM dual;
```

* `SELECT INTERVAL '1' DAY + INTERVAL '1' MINUTE FROM DUAL;` will also work because both sides are of the same interval type `INTERVAL DAY TO SECOND` so operation is valid.
    
* `SELECT INTERVAL '1' DAY + INTERVAL '1' MONTH FROM DUAL;` does not work, because Oracle does not allow direct arithmetic between two interval values of different types:
    
    * `INTERVAL '1' DAY` is of type `INTERVAL DAY TO SECOND`
        
    * `INTERVAL '1' MONTH` is of type `INTERVAL YEAR TO MONTH`